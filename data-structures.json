[
  {
    "data-structure": "Array",
    "global-variable": "customArray",
    "methods": [
      {
        "name": "exponentialSearch(value)",
        "description": "Exponential search algorithm to return index of match. Returns -1 if no match."
      },
      {
        "name": "interpolationSearch(value)",
        "description": "Interpolation search uniformly distributed sorted array and returns index of match. Returns -1 if no match."
      },
      {
        "name": "binarySearch(value)",
        "description": "Binary search sorted array and returns index of match. Returns -1 if no match."
      },
      {
        "name": "binarySearchRecursive(value, left, right)",
        "description": "Recursive binary search sorted array and returns index of match. Returns -1 if no match."
      },
      {
        "name": "jumpSearch(value)",
        "description": "Jump search sorted array and returns index of match. Returns -1 is no match."
      },
      {
        "name": "linearSearch(value)",
        "description": "Linear search an array for value and returns index of match. Returns -1 if no match."
      },
      {
        "name": "improvedLinearSearch(value)",
        "description": "Improved linear search an array for value and returns index of match. Returns -1 if no match."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "createRandomArray(length, lowLimit = 0, highLimit = 10, isSorted = false)",
        "description": "Creates array of specified length with random values in specified range that can be sorted in ascending order."
      },
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Singly Linked List",
    "global-variable": "singlyLinkedList",
    "methods": [
      {
        "name": "size()",
        "description": "Returns number of nodes in SinglyLinkedList instance."
      },
      {
        "name": "sizeRecursive(node = this.head)",
        "description": "Returns number of nodes in SinglyLinkedList instance(recursively)."
      },
      {
        "name": "clear()",
        "description": "Clears SinglyLinkedList instance."
      },
      {
        "name": "print()",
        "description": "Prints each node in SinglyLinkedList instance to console."
      },
      {
        "name": "getLast()",
        "description": "Returns last node in SinglyLinkedList instance."
      },
      {
        "name": "push(data)",
        "description": "Creates new node with data parameter and adds to beginning to SinglyLinkedList."
      },
      {
        "name": "append(data)",
        "description": "Creates new node with data parameter and adds to end of SinglyLinkedList."
      },
      {
        "name": "insertAfter(prevNode, data)",
        "description": "Creates new node with data parameter and inserts after prevNode parameter."
      },
      {
        "name": "deleteNodeWithMatchingKey(key)",
        "description": "Given a 'key', delete the first occurrence of this key in the SinglyLinkedList."
      },
      {
        "name": "deleteNodeAtPosition(position)",
        "description": "Deletes node at zero-indexed position in SinglyLinkedList instance."
      },
      {
        "name": "search(key)",
        "description": "Checks whether the a node with matching key is present in SinglyLinkedList instance."
      },
      {
        "name": "getNth(index)",
        "description": "Returns data of node at index 'n'."
      },
      {
        "name": "getNthRecursive(node = this.head, index)",
        "description": "Returns data of node at index 'n'(recursively)."
      },
      {
        "name": "reverse()",
        "description": "Reverse order of nodes in SinglyLinkedList instance."
      },
      {
        "name": "reverseEveryKNodes(k, headNode)",
        "description": "Reverse SinglyLinkedList instance in groups of given size."
      },
      {
        "name": "createNNodes(n, isRandom = false)",
        "description": "Creates new SinglyLinkedList with n-number of nodes with values ranging from 0-(n-1)."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "mergeTwoSortedLists(firstHeadNode, secondHeadNode)",
        "description": "Merges two sorted SinglyLinkedList instances to one sorted list."
      },
      {
        "name": "mergeSort(headNode)",
        "description": "Merge sort linked list."
      },
      {
        "name": "getMiddle(headNode)",
        "description": "Utility function to get middle of the linked list."
      },
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Doubly Linked List",
    "global-variable": "doublyLinkedList",
    "methods": [
      {
        "name": "push(item)",
        "description": "Inserts new node on the front of the DoublyLinkedList."
      },
      {
        "name": "append(item)",
        "description": "Creates new node with item parameter and adds to end of DoublyLinkedList."
      },
      {
        "name": "insertAfter(prevNode, item)",
        "description": "Creates new node with item parameter and inserts after prevNode parameter."
      },
      {
        "name": "insertBefore(nextNode, item)",
        "description": "Creates new node with item parameter and inserts before nextNode parameter."
      },
      {
        "name": "getLast()",
        "description": "Returns last node in DoublyLinkedList instance."
      },
      {
        "name": "print()",
        "description": "Print each node in DoubleLinkedList instance to console."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Stack With Linked List",
    "global-variable": "stackWithLinkedList",
    "methods": [
      {
        "name": "push(item)",
        "description": "Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition."
      },
      {
        "name": "pop()",
        "description": "Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "peek()",
        "description": "Returns top element of stack."
      },
      {
        "name": "print()",
        "description": "Print each element of stack (top-to-bottom) to console."
      },
      {
        "name": "insertAtBottom(item)",
        "description": "Recursive function that inserts an element at bottom of the stack."
      },
      {
        "name": "reverse()",
        "description": "Reverse the linked list instance using recursive insertAtBottom()"
      },
      {
        "name": "sort(toAscending = true)",
        "description": "Sorts stack with values in ascending/descending order."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "sortedInsert(stack, element)",
        "description": "Insert element into stack in ascending sorted way."
      },
      {
        "name": "sortedInsertDescending(stack, element)",
        "description": "Insert element into stack in descending sorted way."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "infixToPostfix(infixStr)",
        "description": "Convert infix expression to postfix expression."
      },
      {
        "name": "evaluatePostfix(postfix)",
        "description": "Evaluate postfix expression."
      },
      {
        "name": "areBracketsBalanced(bracketStr)",
        "description": "Tests whether brackets in expression are balanced."
      },
      {
        "name": "printNGE(arr, size = arr.length)",
        "description": "Prints the element and Next Greater Element (NGE) pair for all elements of array."
      }
    ]
  },
  {
    "data-structure": "Stack With Array",
    "global-variable": "stackWithArray",
    "methods": [
      {
        "name": "push(item)",
        "description": "Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition."
      },
      {
        "name": "pop()",
        "description": "Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "peek()",
        "description": "Returns top element of stack."
      },
      {
        "name": "print()",
        "description": "Print each element of stack (top-to-bottom) to console."
      },
      {
        "name": "insertAtBottom(item)",
        "description": "Recursive function that inserts an element at bottom of the stack."
      },
      {
        "name": "reverse()",
        "description": "Reverse the linked list instance using recursive insertAtBottom()"
      },
      {
        "name": "sort(toAscending = true)",
        "description": "Sorts stack with values in ascending/descending order."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "sortedInsert(stack, element)",
        "description": "Insert element into stack in ascending sorted way."
      },
      {
        "name": "sortedInsertDescending(stack, element)",
        "description": "Insert element into stack in descending sorted way."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "reverseString(str)",
        "description": "Reverse string using stack data structure."
      }
    ]
  },
  {
    "data-structure": "Two Stacks In Array",
    "global-variable": "twoStacksInArray",
    "methods": [
      {
        "name": "push1(item)",
        "description": "Adds an item in the front stack. If the stack is full, then it is said to be an Overflow condition."
      },
      {
        "name": "push2(item)",
        "description": "Adds an item in the back stack. If the stack is full, then it is said to be an Overflow condition."
      },
      {
        "name": "pop1()",
        "description": "Removes an item from the front stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "pop2()",
        "description": "Removes an item from the back stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Queue With Linked List",
    "global-variable": "queueWithLinkedList",
    "methods": [
      {
        "name": "enqueue(item)",
        "description": "Adds an item to the queue. "
      },
      {
        "name": "dequeue()",
        "description": "Removes an item from the queue. The items are popped in the same order they are pushed. If the queue is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "peekFront()",
        "description": "Get the front item from the queue."
      },
      {
        "name": "peekRear()",
        "description": "Get the last item from the queue."
      },
      {
        "name": "count()",
        "description": "Return number of nodes in queue instance."
      },
      {
        "name": "isEmpty()",
        "description": "Returns if queue is empty."
      },
      {
        "name": "print()",
        "description": "Print queue."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Queue With Array",
    "global-variable": "queueWithArray",
    "methods": [
      {
        "name": "enqueue(item)",
        "description": "Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition."
      },
      {
        "name": "dequeue()",
        "description": "Removes an item from the queue. The items are popped in the same order they are pushed. If the queue is empty, then it is said to be an Underflow condition."
      },
      {
        "name": "peekFront()",
        "description": "Get the front item from the queue."
      },
      {
        "name": "peekRear()",
        "description": "Get the last item from the queue."
      },
      {
        "name": "isEmpty()",
        "description": "Returns if queue is empty."
      },
      {
        "name": "isFull()",
        "description": "Returns if queue is at capacity."
      },
      {
        "name": "print()",
        "description": "Print queue."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "",
        "description": ""
      }
    ]
  },
  {
    "data-structure": "Binary Tree",
    "global-variable": "binaryTree",
    "methods": [
      {
        "name": "inorderTraversal(node = this.root)",
        "description": "Inorder traversal of binary tree instance."
      },
      {
        "name": "insert(item)",
        "description": "Insert item in binary tree at first position available in level order."
      },
      {
        "name": "getMaxDepth",
        "description": "Returns max depth of binary tree."
      },
      {
        "name": "",
        "description": ""
      }
    ],
    "staticMethods": [
      {
        "name": "",
        "description": ""
      }
    ],
    "methodsThatUseDataStructure": [
      {
        "name": "",
        "description": ""
      }
    ]
  }
]

